// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TRANSmittance
#pragma kernel MULTIscattering

#include "Assets/SKY/ATMOSPHERE/Shaders/Utils/Common.hlsl"
#include "Assets/SKY/ATMOSPHERE/Shaders/Utils/AtmosMath.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> TransmittanceResult;
RWTexture2D<float4> MultiscatteringResult;

Texture2D _TransmittanceLut;
SamplerState sampler_TransmittanceLut;


[numthreads(8,8,1)]//定义线程组中的线程数量
void TRANSmittance (uint3 id : SV_DispatchThreadID)
{
    float2 pixPos = id.xy+0.5f;
    float2 uv = pixPos/float2(TRANSMITTANCE_TEXTURE_WIDTH,TRANSMITTANCE_TEXTURE_HEIGHT);//float2(id.x / (float)TRANSMITTANCE_TEXTURE_WIDTH, (id.y) / (float)TRANSMITTANCE_TEXTURE_HEIGHT);
    float2 rMu = GetTransmittanceLutRmu(_PlanetRadius,_AtmosphereRadius,uv);
    float3 res = calOpticalDepthLut(rMu.x, rMu.y);
    TransmittanceResult[id.xy] = float4(res,1);//float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

[numthreads(8,8,1)]//定义线程组中的线程数量
void MULTIscattering (uint3 id : SV_DispatchThreadID)
{
    float2 pixPos = id.xy+0.5f;
    float2 uv = pixPos/float2(MULTISCATTERING_TEXTURE_SIZE,MULTISCATTERING_TEXTURE_SIZE);

    float cos = uv.x * 2.0 - 1.0;
    float r = uv.y * (_AtmosphereRadius - _PlanetRadius);
    float sin = sqrt(1.0 - cos * cos);
    float3 lightDir = float3(sin, cos, 0);
    float3 p = float3(0, r, 0);
    float3 res=calMultiscatteringLut(p, lightDir, _TransmittanceLut, sampler_TransmittanceLut);

    MultiscatteringResult[id.xy] = float4(res,1);//float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
